<!DOCTYPE html>
<html>
<head>
  <meta name='viewport' content='width=device-width, initial-scale=1'>
  <title>Project Euler Solutions</title>
  <link href='https://fonts.googleapis.com/css?family=Cinzel|Source+Sans+Pro|Source+Serif+Pro|Source+Code+Pro' rel='stylesheet'>
  <link href='style.css' rel='stylesheet'>
</head>
<body>
  <h1>Project Euler Solutions</h1>
  <div class='intro'><p>Solutions to the problems on <a href="https://projecteuler.net/">projecteuler.net</a> written in <a href="https://wiki.haskell.org/Literate_programming">Literate Haskell</a>. Source can be found <a href="https://github.com/hot-leaf-juice/project-euler/tree/master/src">here</a>. Click the link to the right of each solution to see the statement of the corresponding problem.</p>
</div>
    <div class='solution' id='001'>
      <h2>
        <a class='problem-title' href='#001'>
          <span class='hash'># </span>
          Multiples of 3 and 5
        </a>
        <a class='problem-statement'
            href='https://projecteuler.net/problem=001'>
          001
        </a>
      </h2>
      <p>This can be solved in constant time with some closed sum formulae, but the obvious list comprehension is super neat and plenty fast.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">s001 <span class="fu">=</span> sum [n <span class="fu">|</span> n <span class="ot">&lt;-</span> [<span class="dv">1</span> <span class="fu">..</span> <span class="dv">999</span>], mod n <span class="dv">3</span> <span class="fu">==</span> <span class="dv">0</span> <span class="fu">||</span> mod n <span class="dv">5</span> <span class="fu">==</span> <span class="dv">0</span>]</code></pre></div>

    </div>
    <div class='solution' id='002'>
      <h2>
        <a class='problem-title' href='#002'>
          <span class='hash'># </span>
          Even Fibonacci numbers
        </a>
        <a class='problem-statement'
            href='https://projecteuler.net/problem=002'>
          002
        </a>
      </h2>
      <p>Pick your favourite <code>fibs</code> definition from <a href="https://wiki.haskell.org/The_Fibonacci_sequence">the Haskell wiki</a>.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">fibs ::</span> [<span class="dt">Integer</span>]
fibs <span class="fu">=</span> <span class="dv">0</span> <span class="fu">:</span> scanl (<span class="fu">+</span>) <span class="dv">1</span> fibs</code></pre></div>
<p>The self reference works here because <code>scanl</code> is only ever consuming values of <code>fibs</code> that we have already calculated. Once we have all the fibbonacci numbers the solution is trivial.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">s002 <span class="fu">=</span> sum <span class="fu">$</span> filter even <span class="fu">$</span> takeWhile (<span class="fu">&lt;=</span> <span class="dv">4</span> <span class="fu">*</span> <span class="dv">10</span> <span class="fu">^</span> <span class="dv">6</span>) fibs</code></pre></div>

    </div>
    <div class='solution' id='003'>
      <h2>
        <a class='problem-title' href='#003'>
          <span class='hash'># </span>
          Largest prime factor
        </a>
        <a class='problem-statement'
            href='https://projecteuler.net/problem=003'>
          003
        </a>
      </h2>
      <p>We calculate the prime factors of <code>n</code> recursively, finding the smallest divisor at each stage. (The smallest divisor is necessarily prime, otherwise it is <code>pq</code> for some prime <code>p</code> and some <code>q &gt; 1</code>, and <code>p</code> is a smaller divisor. Contradiction.)</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">primeFactors ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> [<span class="dt">Integer</span>]
primeFactors <span class="dv">1</span> <span class="fu">=</span> []
primeFactors n <span class="fu">=</span> p <span class="fu">:</span> primeFactors (div n p)
  <span class="kw">where</span>
    p <span class="fu">=</span> head <span class="fu">$</span> filter (\d <span class="ot">-&gt;</span> mod n d <span class="fu">==</span> <span class="dv">0</span>) [<span class="dv">2</span> <span class="fu">..</span>]</code></pre></div>
<p>Given this, the final solution is trivial.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">s003 <span class="fu">=</span> maximum <span class="fu">$</span> primeFactors <span class="dv">600851475143</span></code></pre></div>

    </div>
    <div class='solution' id='004'>
      <h2>
        <a class='problem-title' href='#004'>
          <span class='hash'># </span>
          Largest palindrome product
        </a>
        <a class='problem-statement'
            href='https://projecteuler.net/problem=004'>
          004
        </a>
      </h2>
      <p>The <code>reverse</code> builtin makes writing an <code>isPalindromic</code> function trivial for any type implementing <code>Show</code>.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">isPalindromic ::</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>
isPalindromic x <span class="fu">=</span> show x <span class="fu">==</span> (reverse <span class="fu">.</span> show) x</code></pre></div>
<p>The only minor optimisation worth note here is assuming without loss of generality that <code>x &lt;= y</code>.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">s004 <span class="fu">=</span> maximum <span class="fu">$</span> filter isPalindromic
  [ x <span class="fu">*</span> y
  <span class="fu">|</span> x <span class="ot">&lt;-</span> [<span class="dv">100</span> <span class="fu">..</span> <span class="dv">999</span>]
  , y <span class="ot">&lt;-</span> [x <span class="fu">..</span> <span class="dv">999</span>]
  ]</code></pre></div>

    </div>
    <div class='solution' id='005'>
      <h2>
        <a class='problem-title' href='#005'>
          <span class='hash'># </span>
          Smallest multiple
        </a>
        <a class='problem-statement'
            href='https://projecteuler.net/problem=005'>
          005
        </a>
      </h2>
      <p>Rewording the question, we want the lowest common multiple of all the numbers from 1 to 20, and since (mathematically speaking)</p>
<pre><code>lcm x y z = lcm x (lcm y z)</code></pre>
<p>we can just fold with <code>lcm</code>!</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">s005 <span class="fu">=</span> foldl lcm <span class="dv">1</span> [<span class="dv">1</span> <span class="fu">..</span> <span class="dv">20</span>]</code></pre></div>

    </div>
    <div class='solution' id='006'>
      <h2>
        <a class='problem-title' href='#006'>
          <span class='hash'># </span>
          Sum square difference
        </a>
        <a class='problem-statement'
            href='https://projecteuler.net/problem=006'>
          006
        </a>
      </h2>
      <p>This is just a direct translation of the statement of the question to valid Haskell.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">s006 <span class="fu">=</span> sum [<span class="dv">1</span> <span class="fu">..</span> <span class="dv">100</span>] <span class="fu">^</span> <span class="dv">2</span> <span class="fu">-</span> sum [n <span class="fu">^</span> <span class="dv">2</span> <span class="fu">|</span> n <span class="ot">&lt;-</span> [<span class="dv">1</span> <span class="fu">..</span> <span class="dv">100</span>]]</code></pre></div>

    </div>
    <div class='solution' id='007'>
      <h2>
        <a class='problem-title' href='#007'>
          <span class='hash'># </span>
          10001st prime
        </a>
        <a class='problem-statement'
            href='https://projecteuler.net/problem=007'>
          007
        </a>
      </h2>
      <p>We’ll make use of the <a href="https://hackage.haskell.org/package/data-ordlist-0.4.7.0/docs/Data-List-Ordered.html"><code>Data.List.Ordered</code></a> package; <code>minus</code> is an optimised version of <code>(\\)</code> from <code>Data.List</code> which assumes its operands are ordered.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.List.Ordered</span> (minus)</code></pre></div>
<p>The definition of <code>primesTo</code> comes from <a href="https://wiki.haskell.org/Prime_numbers">the Haskell wiki</a>. This one strikes a nice balance between speed and readability (there are many more optimisations that could be made, at the expense of the latter).</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">primesTo ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> [<span class="dt">Integer</span>]
primesTo n <span class="fu">=</span> eratos [<span class="dv">2</span> <span class="fu">..</span> n]
  <span class="kw">where</span>
    eratos [] <span class="fu">=</span> []
    eratos (p<span class="fu">:</span>xs) <span class="fu">=</span> p <span class="fu">:</span> eratos (minus xs [p <span class="fu">^</span> <span class="dv">2</span>, p <span class="fu">^</span> <span class="dv">2</span> <span class="fu">+</span> p <span class="fu">..</span> n])</code></pre></div>
<p>Note in particular that for each prime found we start eliminating multiples at <code>p ^ 2</code>, since any smaller multiples must have another prime factor smaller than <code>p</code>, and so will have already been removed.</p>
<p>A sufficient number of primes to generate (<code>2 ^ 17</code>) was found manually by trial and error. A more robust solution would use some calculated bound.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">s007 <span class="fu">=</span> primesTo (<span class="dv">2</span> <span class="fu">^</span> <span class="dv">17</span>) <span class="fu">!!</span> <span class="dv">10000</span></code></pre></div>

    </div>
    <div class='solution' id='008'>
      <h2>
        <a class='problem-title' href='#008'>
          <span class='hash'># </span>
          Largest product in a series
        </a>
        <a class='problem-statement'
            href='https://projecteuler.net/problem=008'>
          008
        </a>
      </h2>
      <div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.Char</span> (digitToInt)
<span class="kw">import </span><span class="dt">Data.List</span> (tails)</code></pre></div>
<p>First we define a function that returns “slices” of length <code>n</code> from a list. e.g.</p>
<pre><code>slicesOf 3 [1 .. 5] = [[1, 2, 3], [2, 3, 4], [3, 4, 5]]</code></pre>
<p>By taking the first <code>n</code> <code>tails</code> and then zipping them together.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">slicesOf ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [[a]]
slicesOf n <span class="fu">=</span> foldr (zipWith (<span class="fu">:</span>)) (repeat []) <span class="fu">.</span> take n <span class="fu">.</span> tails</code></pre></div>
<p>The rest of the solution is plumbing to read the input, and to get the largest product of the slices.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">s008 <span class="fu">=</span> <span class="kw">do</span>
  raw <span class="ot">&lt;-</span> readFile <span class="st">&quot;data/008&quot;</span>
  <span class="kw">let</span> grid <span class="fu">=</span> map digitToInt <span class="fu">$</span> concat <span class="fu">$</span> lines raw
  return <span class="fu">$</span> maximum <span class="fu">$</span> map product <span class="fu">$</span> slicesOf <span class="dv">13</span> grid</code></pre></div>

    </div>
    <div class='solution' id='009'>
      <h2>
        <a class='problem-title' href='#009'>
          <span class='hash'># </span>
          Special Pythagorean triplet
        </a>
        <a class='problem-statement'
            href='https://projecteuler.net/problem=009'>
          009
        </a>
      </h2>
      <p>Assume without loss of generality that <code>a &lt;= b &lt;= c</code>, and then find all such triplets with a list comprehension.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">tripletsWithPerimeter ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> [[<span class="dt">Integer</span>]]
tripletsWithPerimeter n <span class="fu">=</span>
  [ [a, b, c]
  <span class="fu">|</span> a <span class="ot">&lt;-</span> [<span class="dv">1</span> <span class="fu">..</span> n]
  , b <span class="ot">&lt;-</span> [a <span class="fu">..</span> n]
  , <span class="kw">let</span> c <span class="fu">=</span> n <span class="fu">-</span> a <span class="fu">-</span> b
  , c <span class="fu">&gt;=</span> b
  , a <span class="fu">^</span> <span class="dv">2</span> <span class="fu">+</span> b <span class="fu">^</span> <span class="dv">2</span> <span class="fu">==</span> c <span class="fu">^</span> <span class="dv">2</span>
  ]</code></pre></div>
<p>Trust the question and extract our single match with <code>head</code>.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">s009 <span class="fu">=</span> product <span class="fu">$</span> head <span class="fu">$</span> tripletsWithPerimeter <span class="dv">1000</span></code></pre></div>

    </div>
    <div class='solution' id='010'>
      <h2>
        <a class='problem-title' href='#010'>
          <span class='hash'># </span>
          Summation of primes
        </a>
        <a class='problem-statement'
            href='https://projecteuler.net/problem=010'>
          010
        </a>
      </h2>
      <div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.List.Ordered</span> (minus)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">primesTo ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> [<span class="dt">Integer</span>]
primesTo n <span class="fu">=</span> eratos [<span class="dv">2</span> <span class="fu">..</span> n]
  <span class="kw">where</span>
    eratos [] <span class="fu">=</span> []
    eratos (p<span class="fu">:</span>xs) <span class="fu">=</span> p <span class="fu">:</span> eratos (minus xs [p <span class="fu">^</span> <span class="dv">2</span>, p <span class="fu">^</span> <span class="dv">2</span> <span class="fu">+</span> p <span class="fu">..</span> n])</code></pre></div>
<p>Using our same <code>primesTo</code> function from <a href="#007">problem 007</a>, the solution is trivial.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">s010 <span class="fu">=</span> sum <span class="fu">$</span> primesTo <span class="fu">$</span> <span class="dv">2</span> <span class="fu">*</span> <span class="dv">10</span> <span class="fu">^</span> <span class="dv">6</span> <span class="fu">-</span> <span class="dv">1</span></code></pre></div>

    </div>
    <div class='solution' id='011'>
      <h2>
        <a class='problem-title' href='#011'>
          <span class='hash'># </span>
          Largest product in a grid
        </a>
        <a class='problem-statement'
            href='https://projecteuler.net/problem=011'>
          011
        </a>
      </h2>
      <p>We’re going to want to store our grid as a two dimensional <a href="https://hackage.haskell.org/package/array-0.5.2.0/docs/Data-Array.html">Array</a>.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.Array</span> (<span class="dt">Array</span>, bounds, listArray, (!))
<span class="kw">import </span><span class="dt">Data.Ix</span> (inRange, range)

<span class="kw">type</span> <span class="dt">Grid</span> <span class="fu">=</span> <span class="dt">Array</span> (<span class="dt">Int</span>, <span class="dt">Int</span>) <span class="dt">Integer</span></code></pre></div>
<p>Given some grid we can get all of the products of four adjacent elements as follows.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">adjacentProducts ::</span> <span class="dt">Grid</span> <span class="ot">-&gt;</span> [<span class="dt">Integer</span>]
adjacentProducts grid <span class="fu">=</span>
  [ product <span class="fu">$</span> map (grid <span class="fu">!</span>) is
  <span class="fu">|</span> (x, y) <span class="ot">&lt;-</span> range <span class="fu">$</span> bounds grid
  , (dx, dy) <span class="ot">&lt;-</span> [(<span class="dv">1</span>, <span class="dv">0</span>), (<span class="dv">0</span>, <span class="dv">1</span>), (<span class="dv">1</span>, <span class="dv">1</span>), (<span class="dv">1</span>, <span class="fu">-</span><span class="dv">1</span>)]
  , <span class="kw">let</span> is <span class="fu">=</span> [(x <span class="fu">+</span> k <span class="fu">*</span> dx, y <span class="fu">+</span> k <span class="fu">*</span> dy) <span class="fu">|</span> k <span class="ot">&lt;-</span> [<span class="dv">0</span> <span class="fu">..</span> <span class="dv">3</span>]]
  , all (inRange (bounds grid)) is
  ]</code></pre></div>
<p>There’s quite a lot going on here so let’s walk through it. We’re taking each index <code>i</code> in the grid, and then for each possible direction, we’re calculating the four adjacent indices gotten by starting at <code>i</code> and moving in that direction – zero to three times. Finally we’re just checking that each of the indices is within our grid and extracting the actual product of the elements at these positions.</p>
<p>All that remains is to write a function for building a <code>Grid</code> from the raw input string, and plumb everything together to find the maximum product.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">mkGrid ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Grid</span>
mkGrid <span class="fu">=</span> listArray ((<span class="dv">0</span>, <span class="dv">0</span>), (<span class="dv">19</span>, <span class="dv">19</span>)) <span class="fu">.</span> map read <span class="fu">.</span> words

s011 <span class="fu">=</span> maximum <span class="fu">.</span> adjacentProducts <span class="fu">.</span> mkGrid <span class="fu">&lt;$&gt;</span> readFile <span class="st">&quot;data/011&quot;</span></code></pre></div>

    </div>
    <div class='solution' id='012'>
      <h2>
        <a class='problem-title' href='#012'>
          <span class='hash'># </span>
          Highly divisible triangular number
        </a>
        <a class='problem-statement'
            href='https://projecteuler.net/problem=012'>
          012
        </a>
      </h2>
      <p>First we’re going to need a function for calculating divisors. We’ll just check each potential divisor up to the square root, adding a pair of divisors at a time (aside from when <code>n</code> is square).</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">intSqrt ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>
intSqrt <span class="fu">=</span> floor <span class="fu">.</span> sqrt <span class="fu">.</span> fromIntegral</code></pre></div>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">divisors ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> [<span class="dt">Integer</span>]
divisors n <span class="fu">=</span>
  [ d&#39;
  <span class="fu">|</span> d <span class="ot">&lt;-</span> filter ((<span class="fu">==</span> <span class="dv">0</span>) <span class="fu">.</span> mod n) [<span class="dv">1</span> <span class="fu">..</span> intSqrt n]
  , d&#39; <span class="ot">&lt;-</span> <span class="kw">if</span> d <span class="fu">^</span> <span class="dv">2</span> <span class="fu">==</span> n <span class="kw">then</span> [d] <span class="kw">else</span> [d, div n d]
  ]</code></pre></div>
<p>The list of all triangular numbers is a neat scan.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">triangles ::</span> [<span class="dt">Integer</span>]
triangles <span class="fu">=</span> scanl1 (<span class="fu">+</span>) [<span class="dv">0</span> <span class="fu">..</span>]</code></pre></div>
<p>Finally just find the first triangular number with more than 500 divisors.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">s012 <span class="fu">=</span> head <span class="fu">$</span> filter ((<span class="fu">&gt;</span> <span class="dv">500</span>) <span class="fu">.</span> length <span class="fu">.</span> divisors) <span class="fu">$</span> triangles</code></pre></div>

    </div>
    <div class='solution' id='013'>
      <h2>
        <a class='problem-title' href='#013'>
          <span class='hash'># </span>
          Large sum
        </a>
        <a class='problem-statement'
            href='https://projecteuler.net/problem=013'>
          013
        </a>
      </h2>
      <div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="dt">This</span> one is trivial<span class="fu">.</span>

s013 <span class="fu">=</span>
  take <span class="dv">10</span> <span class="fu">.</span> show <span class="fu">.</span> sum <span class="fu">.</span> map read <span class="fu">.</span> lines <span class="fu">&lt;$&gt;</span>
  readFile <span class="st">&quot;data/013&quot;</span></code></pre></div>

    </div>
    <div class='solution' id='014'>
      <h2>
        <a class='problem-title' href='#014'>
          <span class='hash'># </span>
          Longest Collatz sequence
        </a>
        <a class='problem-statement'
            href='https://projecteuler.net/problem=014'>
          014
        </a>
      </h2>
      <div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.Array</span> (<span class="dt">Array</span>, assocs, listArray, (!))
<span class="kw">import </span><span class="dt">Data.List</span> (maximumBy)
<span class="kw">import </span><span class="dt">Data.Ord</span> (comparing)</code></pre></div>
<p>It’s tempting to write a function to calculate the Collatz length of a given integer, and then to map that over every integer in the range to find our maximum. However, if, for example, we already know the Collatz length of 20, and we want to know the Collatz length of 40, it is unnecessary to recalculate the Collatz length of 20. We can do a lot better by calculating every Collatz length we care about together, and referencing values we already know.</p>
<p>To that end, the following function populates an array of the Collatz lengths of all the numbers from 1 to its input.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">collatzLengths ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Array</span> <span class="dt">Integer</span> <span class="dt">Integer</span>
collatzLengths n <span class="fu">=</span> memo
  <span class="kw">where</span>
    memo <span class="fu">=</span> listArray (<span class="dv">1</span>, n) [collatzLength m <span class="fu">|</span> m <span class="ot">&lt;-</span> [<span class="dv">1</span> <span class="fu">..</span> n]]
    collatzLength <span class="dv">1</span> <span class="fu">=</span> <span class="dv">1</span>
    collatzLength m
      <span class="fu">|</span> k <span class="fu">&lt;=</span> n <span class="fu">=</span> <span class="dv">1</span> <span class="fu">+</span> memo <span class="fu">!</span> k
      <span class="fu">|</span> k <span class="fu">&gt;</span> n <span class="fu">=</span> <span class="dv">1</span> <span class="fu">+</span> collatzLength k
      <span class="kw">where</span>
        k <span class="fu">=</span> <span class="kw">if</span> even m <span class="kw">then</span> div m <span class="dv">2</span> <span class="kw">else</span> <span class="dv">3</span> <span class="fu">*</span> m <span class="fu">+</span> <span class="dv">1</span></code></pre></div>
<p><code>memo</code> is lazily populated, and defers to <code>collatzLength</code>, but once we have calculated <code>collatzLength m</code> once, we can just look it up in <code>memo</code> on subsequent calls.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">s014 <span class="fu">=</span>
  fst <span class="fu">$</span> maximumBy (comparing snd) <span class="fu">$</span> assocs <span class="fu">$</span>
  collatzLengths <span class="fu">$</span> <span class="dv">10</span> <span class="fu">^</span> <span class="dv">6</span> <span class="fu">-</span> <span class="dv">1</span></code></pre></div>

    </div>
    <div class='solution' id='015'>
      <h2>
        <a class='problem-title' href='#015'>
          <span class='hash'># </span>
          Lattice paths
        </a>
        <a class='problem-statement'
            href='https://projecteuler.net/problem=015'>
          015
        </a>
      </h2>
      <p>This is a one liner with some combinatorics, but let’s solve it in a slightly more interesting way. Imagine labelling each point in our lattice with the number of routes that end at that point. (Indexing from <code>(0, 0)</code> in the top left corner.)</p>
<ul>
<li><p>Every point at the top or left edge of the lattice has precisely one route to it (consisting of just left or just down repeatedly).</p></li>
<li><p>For every other point, <code>(x, y)</code>, each route that ends at <code>(x, y)</code> must pass through either the point immediately above or immediately to the right, so the number of routes to <code>(x, y)</code> is the sum of the number of routes to <code>(x -   1, y)</code> and the number of routes to <code>(x, y - 1)</code>. The implementation then is a straightforward recursion, which we memoize for efficiency.</p></li>
</ul>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.Array</span> (<span class="dt">Array</span>, listArray, range, (!))

lattice
<span class="ot">  ::</span> ((<span class="dt">Integer</span>, <span class="dt">Integer</span>), (<span class="dt">Integer</span>, <span class="dt">Integer</span>))
  <span class="ot">-&gt;</span> <span class="dt">Array</span> (<span class="dt">Integer</span>, <span class="dt">Integer</span>) <span class="dt">Integer</span>
lattice ix <span class="fu">=</span> memo
  <span class="kw">where</span>
    memo <span class="fu">=</span> listArray ix [lattice&#39; i <span class="fu">|</span> i <span class="ot">&lt;-</span> range ix]
    lattice&#39; (x, y)
      <span class="fu">|</span> x <span class="fu">==</span> <span class="dv">0</span> <span class="fu">||</span> y <span class="fu">==</span> <span class="dv">0</span> <span class="fu">=</span> <span class="dv">1</span>
      <span class="fu">|</span> otherwise <span class="fu">=</span> memo <span class="fu">!</span> (x <span class="fu">-</span> <span class="dv">1</span>, y) <span class="fu">+</span> memo <span class="fu">!</span> (x, y <span class="fu">-</span> <span class="dv">1</span>)

s015 <span class="fu">=</span> lattice ((<span class="dv">0</span>, <span class="dv">0</span>), (<span class="dv">20</span>, <span class="dv">20</span>)) <span class="fu">!</span> (<span class="dv">20</span>, <span class="dv">20</span>)</code></pre></div>
<p>There’s an outrageously neat solution on <a href="https://wiki.haskell.org/Euler_problems/11_to_20">the Haskell wiki</a> that works in a very similar way, but makes a couple more logical jumps so is slightly harder to unpack. I’ll leave it here becuse it’s awesome.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">s015&#39; <span class="fu">=</span> iterate (scanl1 (<span class="fu">+</span>)) (repeat <span class="dv">1</span>) <span class="fu">!!</span> <span class="dv">20</span> <span class="fu">!!</span> <span class="dv">20</span></code></pre></div>

    </div>
    <div class='solution' id='016'>
      <h2>
        <a class='problem-title' href='#016'>
          <span class='hash'># </span>
          Power digit sum
        </a>
        <a class='problem-statement'
            href='https://projecteuler.net/problem=016'>
          016
        </a>
      </h2>
      <p>This one is pretty trivial.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.Char</span> (digitToInt)

s016 <span class="fu">=</span> sum <span class="fu">$</span> map digitToInt <span class="fu">$</span> show <span class="fu">$</span> <span class="dv">2</span> <span class="fu">^</span> <span class="dv">1000</span></code></pre></div>

    </div>
    <div class='solution' id='017'>
      <h2>
        <a class='problem-title' href='#017'>
          <span class='hash'># </span>
          Number letter counts
        </a>
        <a class='problem-statement'
            href='https://projecteuler.net/problem=017'>
          017
        </a>
      </h2>
      <p>This is pretty dull, but it works.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">say ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
say n
  <span class="fu">|</span> n <span class="fu">==</span> <span class="dv">1</span> <span class="fu">=</span> <span class="st">&quot;one&quot;</span>
  <span class="fu">|</span> n <span class="fu">==</span> <span class="dv">2</span> <span class="fu">=</span> <span class="st">&quot;two&quot;</span>
  <span class="fu">|</span> n <span class="fu">==</span> <span class="dv">3</span> <span class="fu">=</span> <span class="st">&quot;three&quot;</span>
  <span class="fu">|</span> n <span class="fu">==</span> <span class="dv">4</span> <span class="fu">=</span> <span class="st">&quot;four&quot;</span>
  <span class="fu">|</span> n <span class="fu">==</span> <span class="dv">5</span> <span class="fu">=</span> <span class="st">&quot;five&quot;</span>
  <span class="fu">|</span> n <span class="fu">==</span> <span class="dv">6</span> <span class="fu">=</span> <span class="st">&quot;six&quot;</span>
  <span class="fu">|</span> n <span class="fu">==</span> <span class="dv">7</span> <span class="fu">=</span> <span class="st">&quot;seven&quot;</span>
  <span class="fu">|</span> n <span class="fu">==</span> <span class="dv">8</span> <span class="fu">=</span> <span class="st">&quot;eight&quot;</span>
  <span class="fu">|</span> n <span class="fu">==</span> <span class="dv">9</span> <span class="fu">=</span> <span class="st">&quot;nine&quot;</span>
  <span class="fu">|</span> n <span class="fu">==</span> <span class="dv">10</span> <span class="fu">=</span> <span class="st">&quot;ten&quot;</span>
  <span class="fu">|</span> n <span class="fu">==</span> <span class="dv">11</span> <span class="fu">=</span> <span class="st">&quot;eleven&quot;</span>
  <span class="fu">|</span> n <span class="fu">==</span> <span class="dv">12</span> <span class="fu">=</span> <span class="st">&quot;twelve&quot;</span>
  <span class="fu">|</span> n <span class="fu">==</span> <span class="dv">13</span> <span class="fu">=</span> <span class="st">&quot;thirteen&quot;</span>
  <span class="fu">|</span> n <span class="fu">==</span> <span class="dv">15</span> <span class="fu">=</span> <span class="st">&quot;fifteen&quot;</span>
  <span class="fu">|</span> n <span class="fu">==</span> <span class="dv">18</span> <span class="fu">=</span> <span class="st">&quot;eighteen&quot;</span>
  <span class="fu">|</span> n <span class="fu">&lt;</span> <span class="dv">20</span> <span class="fu">=</span> say (mod n <span class="dv">10</span>) <span class="fu">++</span> <span class="st">&quot;teen&quot;</span>
  <span class="fu">|</span> n <span class="fu">==</span> <span class="dv">20</span> <span class="fu">=</span> <span class="st">&quot;twenty&quot;</span>
  <span class="fu">|</span> n <span class="fu">==</span> <span class="dv">30</span> <span class="fu">=</span> <span class="st">&quot;thirty&quot;</span>
  <span class="fu">|</span> n <span class="fu">==</span> <span class="dv">40</span> <span class="fu">=</span> <span class="st">&quot;forty&quot;</span>
  <span class="fu">|</span> n <span class="fu">==</span> <span class="dv">50</span> <span class="fu">=</span> <span class="st">&quot;fifty&quot;</span>
  <span class="fu">|</span> n <span class="fu">==</span> <span class="dv">80</span> <span class="fu">=</span> <span class="st">&quot;eighty&quot;</span>
  <span class="fu">|</span> n <span class="fu">&lt;</span> <span class="dv">100</span> <span class="fu">&amp;&amp;</span> mod n <span class="dv">10</span> <span class="fu">==</span> <span class="dv">0</span> <span class="fu">=</span> say (div n <span class="dv">10</span>) <span class="fu">++</span> <span class="st">&quot;ty&quot;</span>
  <span class="fu">|</span> n <span class="fu">&lt;</span> <span class="dv">100</span> <span class="fu">=</span> say (div n <span class="dv">10</span> <span class="fu">*</span> <span class="dv">10</span>) <span class="fu">++</span> say (mod n <span class="dv">10</span>)
  <span class="fu">|</span> n <span class="fu">&lt;</span> <span class="dv">1000</span> <span class="fu">&amp;&amp;</span> mod n <span class="dv">100</span> <span class="fu">==</span> <span class="dv">0</span> <span class="fu">=</span> say (div n <span class="dv">100</span>) <span class="fu">++</span> <span class="st">&quot;hundred&quot;</span>
  <span class="fu">|</span> n <span class="fu">&lt;</span> <span class="dv">1000</span> <span class="fu">=</span> say (div n <span class="dv">100</span> <span class="fu">*</span> <span class="dv">100</span>) <span class="fu">++</span> <span class="st">&quot;and&quot;</span> <span class="fu">++</span> say (mod n <span class="dv">100</span>)
  <span class="fu">|</span> n <span class="fu">==</span> <span class="dv">1000</span> <span class="fu">=</span> <span class="st">&quot;onethousand&quot;</span>

s017 <span class="fu">=</span> sum <span class="fu">$</span> map (length <span class="fu">.</span> say) <span class="fu">$</span> [<span class="dv">1</span> <span class="fu">..</span> <span class="dv">1000</span>]</code></pre></div>

    </div>
    <div class='solution' id='018'>
      <h2>
        <a class='problem-title' href='#018'>
          <span class='hash'># </span>
          Maximum path sum I
        </a>
        <a class='problem-statement'
            href='https://projecteuler.net/problem=018'>
          018
        </a>
      </h2>
      <p>We’ll represent the triangle as a nested list. Actually calculating the maximum total from top to bottom can be done in one pass, folding from bottom to top and accumulating the maximum totals.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">maxTotal ::</span> [[<span class="dt">Integer</span>]] <span class="ot">-&gt;</span> <span class="dt">Integer</span>
maxTotal <span class="fu">=</span>
  head <span class="fu">.</span> foldr1 (\row acc <span class="ot">-&gt;</span> zipWith3 newTotal row acc (tail acc))
  <span class="kw">where</span>
    newTotal new left right <span class="fu">=</span> new <span class="fu">+</span> max left right</code></pre></div>
<p>Building the triangle and applying <code>maxTotal</code>.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">s018 <span class="fu">=</span>
  maxTotal <span class="fu">.</span> map (map read) <span class="fu">.</span> map words <span class="fu">.</span> lines <span class="fu">&lt;$&gt;</span>
  readFile <span class="st">&quot;data/018&quot;</span></code></pre></div>

    </div>
    <div class='solution' id='019'>
      <h2>
        <a class='problem-title' href='#019'>
          <span class='hash'># </span>
          Counting Sundays
        </a>
        <a class='problem-statement'
            href='https://projecteuler.net/problem=019'>
          019
        </a>
      </h2>
      <p>We can make our life a lot easier by using <code>Data.Time</code> rather than re-inventing the wheel.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.Time.Calendar</span> (fromGregorian)
<span class="kw">import </span><span class="dt">Data.Time.Calendar.WeekDate</span> (toWeekDate)</code></pre></div>
<p>Then we can just count Sundays over a range of days.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">s019 <span class="fu">=</span> length <span class="fu">$</span> filter ((\(_, _, d) <span class="ot">-&gt;</span> d <span class="fu">==</span> <span class="dv">7</span>) <span class="fu">.</span> toWeekDate) <span class="fu">$</span>
  [fromGregorian y m <span class="dv">1</span> <span class="fu">|</span> y <span class="ot">&lt;-</span> [<span class="dv">1901</span> <span class="fu">..</span> <span class="dv">2000</span>], m <span class="ot">&lt;-</span> [<span class="dv">1</span> <span class="fu">..</span> <span class="dv">12</span>]]</code></pre></div>

    </div>
    <div class='solution' id='020'>
      <h2>
        <a class='problem-title' href='#020'>
          <span class='hash'># </span>
          Factorial digit sum
        </a>
        <a class='problem-statement'
            href='https://projecteuler.net/problem=020'>
          020
        </a>
      </h2>
      <p>An easy one liner.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.Char</span> (digitToInt)

s020 <span class="fu">=</span> sum <span class="fu">$</span> map digitToInt <span class="fu">$</span> show <span class="fu">$</span> product [<span class="dv">1</span> <span class="fu">..</span> <span class="dv">100</span>]</code></pre></div>

    </div>
</body>
</html>

